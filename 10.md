# 유연한 설계

- 소프트웨어의 궁극적인 목적은 사용자를 만족시키는 것이지만, 그 전에 개발자를 만족시켜야 한다.
- 개발자들이 소프트웨어의 처리 방식에 내포된 모든 의미를 확신하지 못하면 곧바로 중복이 나타나기 시작한다.
- 소프트웨어가 깔끔하게 설계돼 있지 않다면 개발자들은 뭔가를 망가트릴지도 모르는 변경을 덜하게 될 것이다 -> 취약성은 리팩터링과 반복적인 정제를 방해한다.
- 개발이 진행될수록 레거시 코드로 인한 중압감에 시달리지 않으려면 변경을 수용하고 즐겁게 작업할 수 있느 설계가 필요하다 -> 유연한 ㅓㄹ계

### 의도를 드러내는 인터페이스

- 모델링된 객체를 구현하려면 계산의 까다로운 세부 내용이나 놓치기 쉬운 규칙의 세부사항을 이해해야 한다.
- 객체가 아름다운 이유는 이 모든 것들을 캡슐화 할 수 있기 때문이다.
- 개발자가 컴포넌트를 사용하기 위헤 컴포넌트의 구현 세부사항을 고려해야 한다면 캡슐화의 가치는 사라진다.
- 결가와 목적만을 표현하도록 클래스와 연산의 이름을 부여하라.

```kotlin
// 얘가 뭘하는지 모름
fun paint(paint: Paint) {
    // ...
}

// 색깔을 섞는 애구나 !
fun mixIn(paint: Paint)
```

### 부수효과가 없는 함수

- 연산은 크게 명령과 질의라는 두가지 범주로 나눌 수 있다.
  - 질의는 변수 안에 저장된 데이터에 접근하거나, 저장된 데이터를 기반으로 계산을 수행해서 시스템으로부터 정보를 얻는 연산을 의미한다.
  - 명령은 변수의 값을 변경하는 등의 작업을 통해 시스템의 상태를 변경하는 연산을 의미한다.
  - 일반 영어에서는 부수효과가 의도하지 않은 결과를 의미하지만 컴퓨터 과학에서는 시스템의 상태에 대한 영향력을 의미한다.
- 연산을 호출하는 개발자가 결과를 예상하려면 연산 자체의 구현뿐 아니라 연산이 호출하는 다른 연산의 구현도 이해해야 한다.
- 부수효과를 일으키지 않으면서 결과를 반환하는 연산을 <b>함수</b>라고 한다.

##### 명령의 문제를 완화하는 방법

- 명령과 질의를 엄격하게 분리된 서로 다른 연산으로 유지한다.
- 기존의 객체를 전혀 변경하지 않고도 문제를 완화할 수 있는 대안적인 모델과 설계가 있다. -> 새로운 VO를 생성해서 반환한다.

### 단언 (Assertion)

- 연산의 부수효과가 단지 구현에 의해서만 함축적으로 정의될 때 다수의 위임을 포함하는 설계는 인과 관계로 혼란스러워진다 -> 분기 경로를 따라 실행 경로 추적.... -> 캡슐화의 가치 실종!
- 내부를 조사하지 않고도 설계 요소의 의미와 연산의 실행 결과를 이해할 수 있는 방법이 필요! -> <b>연산의 사후조건과 클래스 및 AGGREGATE의 불변식을 명시할 것!</b>
- assertion은 절차가 아니라 상태에 대해서만 기술하므로 테스트로 작성하기 쉽당

### 개념적 윤곽 (Conceptual Contour)

- 모델 또는 설계를 구성하는 요소가 모놀리식 구조에 묻혀있을 경우 각 요소의 기능이 중복된다.
- 반복적인 리팩터링을 통해 유연한 설계를 얻게 되는 이유 -> 새로 알게 된 개념이나 요구사항을 코드에 적용하다보면 CONCEPTUAL CONTOUR가 나타난다.
- 도메인을 중요 영역을 나누는 것과 관련된 직관을 감안해서 설계 요소 (연산, 인터페이스, 클래스, AGGREGATE)를 응집력 있는 단위로 분해하라.

### 독립형 클래스 (STANDLONE CLASS)

- 클래스를 이해하려면 연관관계를 토대로 어떤 요소가 연결돼 있는지 이해해야 한다.
- MODULE과 AGGREGATE 모두 지나치게 얽히고 설키는 상호의존성을 방지하는 것이 목적.
- 낮은 결합도는 객체 설계의 기본 원리다. 가능한 한 늘 결합도를 낮추고자 노력하라. 현재 상황과 무관한 모든 개념을 제거하라.

### 연산의 닫힘 (CLOSURE OF OPERATION)

- 적절한 위치에 반환 타입과 인자 타입이 동일한 연산을 정의하라.
- 연산의 인자로 구현자를 사용하는 것이 효과적이므로 인자의 타입과 반환 타입을 구현자의 타입과 동일하게 정의한다.
