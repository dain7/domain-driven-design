# 모델과 디자인 패턴의 연결
- 디자인 패턴: 특정한 상황에서 일반적인 설계 문제를 해결하고자 상호 교류하는 수정 가능한 객체와 클래스에 관한 설명
- 디자인 패턴에서 강조하는 사항을 도메인 패턴에 맞게 적절하게 수정해야 한다.


### Strategy (전략, 정책)
- 도메인 모델에는 기술적인 이유로 필요한 것이 아니라 실제적으로 문제 도메인 관점에서 의미있는 프로세스가 존재한다. 
- STRATEGY는 모델에 표함된 하나의 개념으로 사용되며 해당 모델을 구현한 코드에 반영된다.

<b>프로세스에서 변화하는 부분을 별도의 전략 객체로 분리해서 모델에 표현하라!</b>

##### example
- 항로를 계산하는 모든 곳에 가장 빠른 항로나 가장 저렴한 항로 중 하나를 선택하는 조건 로직이 나타난다는 사실을 알 수 있다.
- 빠른 항로나 저렴한 항로 중 어떤 것을 선택해야 하는지를 표현하는 조정 매개변수를 STRATEGY로 분리하는 것이다.

### Composite (복합체)
- 중요한 객체가 여러 개의 작은 부분으로 조합되어 구성돼 있는 경우가 있다.
- 중첩돼 있는 복합 객체 간의 관련성을 모델에 반영하지 않을 경우 계층 구조상의 각 수준에 공통적인 행위를 중복시킬 수 밖에 없으며 복합 객체 내에 객체들을 중첩할 수 있는 유연성이 손상된다.
- 적용하려는 패턴의 기본 아이디어가 정말로 도메인 개념에 적합한지 여부다.

- Component → 단일(Leaf), 복합(Composite) 상관없이 상속받을 인터페이스
- Composite → 단일, 복합 객체를 둘 다 가지고 있다.
- Leaf → 단순 정보를 나타내는 단일 객체

```kotlin
// 인터페이스 선언 (단일, 복합 둘 다 관리)
interface Component {
   fun operation()
}

// 복합 클래스 선언
class Composite(): Component {
  val components: List<Component> = listof()
  
  @override
  fun operation() {
    print("호출")
    // 내부 리스트를 순회하여, 단일 Leaf이면 값을 출력하고,
    // 또다른 서브 복합 객체이면, 다시 그 내부를 순회하는 재귀 함수 동작이 된다.
    for (Component component : components) {
        component.operation() // 자기 자신을 호출(재귀)
    }
  }
}

class Leaf(): Component {
    @override
    fun operation() {
        print("호출")
    }
}
```